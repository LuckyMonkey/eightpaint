<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hexagonal Pixel Drawing Demo</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background: #111;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #111;
      cursor: crosshair;
    }
    canvas.panning {
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <canvas id="hexCanvas"></canvas>
  <script>
    const canvas = document.getElementById('hexCanvas');
    const ctx = canvas.getContext('2d');

    const hexSize = 20;
    const horiz = Math.sqrt(3) * hexSize;
    const vert = 1.5 * hexSize;

    // Camera offset in world-space. screen = world - camera.
    let cameraX = 0;
    let cameraY = 0;

    const defaultColor = '#222';
    const storageKey = 'eightpaint-painted-cells-v1';

    // Persist only painted cells so drawings survive resize/panning.
    const paintedCells = new Map();
    let lastPaintColor = 'hsl(190, 70%, 50%)';

    const evenRowNeighbors = [
      [+1,  0], [ 0, -1], [-1, -1],
      [-1,  0], [-1, +1], [ 0, +1],
    ];
    const oddRowNeighbors = [
      [+1,  0], [+1, -1], [ 0, -1],
      [-1,  0], [ 0, +1], [+1, +1],
    ];

    let isPanning = false;
    let startPanMouseX = 0;
    let startPanMouseY = 0;
    let startPanCameraX = 0;
    let startPanCameraY = 0;

    function cellKey(row, col) {
      return `${row},${col}`;
    }

    function getCellColor(row, col) {
      return paintedCells.get(cellKey(row, col)) || defaultColor;
    }

    function setCellColor(row, col, color) {
      const key = cellKey(row, col);
      if (color === defaultColor) {
        paintedCells.delete(key);
      } else {
        paintedCells.set(key, color);
      }
    }

    function savePaintedCells() {
      try {
        localStorage.setItem(storageKey, JSON.stringify(Object.fromEntries(paintedCells)));
      } catch (err) {
        // Ignore storage failures (e.g. private mode quota issues).
      }
    }

    function loadPaintedCells() {
      try {
        const raw = localStorage.getItem(storageKey);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        for (const [key, color] of Object.entries(parsed)) {
          if (typeof color === 'string' && color !== defaultColor) {
            paintedCells.set(key, color);
            lastPaintColor = color;
          }
        }
      } catch (err) {
        // Ignore malformed/blocked localStorage and continue with blank canvas.
      }
    }

    function hexCenterX(row, col) {
      return col * horiz + ((row & 1) ? horiz / 2 : 0);
    }

    function drawHex(x, y, color) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 180) * (60 * i + 30);
        const vx = x + hexSize * Math.cos(angle);
        const vy = y + hexSize * Math.sin(angle);
        if (i === 0) ctx.moveTo(vx, vy);
        else ctx.lineTo(vx, vy);
      }
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#444';
      ctx.stroke();
    }

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const worldMinY = cameraY - hexSize;
      const worldMaxY = cameraY + canvas.height + hexSize;
      const minRow = Math.floor(worldMinY / vert) - 1;
      const maxRow = Math.ceil(worldMaxY / vert) + 1;

      for (let row = minRow; row <= maxRow; row++) {
        const shift = (row & 1) ? horiz / 2 : 0;
        const worldMinX = cameraX - hexSize;
        const worldMaxX = cameraX + canvas.width + hexSize;
        const minCol = Math.floor((worldMinX - shift) / horiz) - 1;
        const maxCol = Math.ceil((worldMaxX - shift) / horiz) + 1;

        for (let col = minCol; col <= maxCol; col++) {
          const worldX = hexCenterX(row, col);
          const worldY = row * vert;
          const screenX = worldX - cameraX;
          const screenY = worldY - cameraY;
          drawHex(screenX, screenY, getCellColor(row, col));
        }
      }
    }

    function screenToCell(mouseX, mouseY) {
      const worldX = mouseX + cameraX;
      const worldY = mouseY + cameraY;
      const row = Math.floor(worldY / vert);
      const shift = (row & 1) ? horiz / 2 : 0;
      const col = Math.floor((worldX - shift) / horiz);
      return { row, col };
    }

    function paintAtMouse(evt) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = evt.clientX - rect.left;
      const mouseY = evt.clientY - rect.top;
      const { row, col } = screenToCell(mouseX, mouseY);

      const color = lastPaintColor;
      setCellColor(row, col, color);

      const neighbors = (row & 1) ? oddRowNeighbors : evenRowNeighbors;
      for (const [dx, dy] of neighbors) {
        setCellColor(row + dy, col + dx, color);
      }

      savePaintedCells();
      drawGrid();
    }

    function eraseAtMouse(evt) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = evt.clientX - rect.left;
      const mouseY = evt.clientY - rect.top;
      const { row, col } = screenToCell(mouseX, mouseY);

      // Erasing should not change the active paint color.
      setCellColor(row, col, defaultColor);

      const neighbors = (row & 1) ? oddRowNeighbors : evenRowNeighbors;
      for (const [dx, dy] of neighbors) {
        setCellColor(row + dy, col + dx, defaultColor);
      }

      savePaintedCells();
      drawGrid();
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      drawGrid();
    }

    canvas.addEventListener('click', (evt) => {
      if (!isPanning && evt.button === 0) {
        paintAtMouse(evt);
      }
    });

    canvas.addEventListener('mousedown', (evt) => {
      // Pan with middle-click or Shift + left-click drag.
      if (evt.button === 1 || (evt.button === 0 && evt.shiftKey)) {
        isPanning = true;
        startPanMouseX = evt.clientX;
        startPanMouseY = evt.clientY;
        startPanCameraX = cameraX;
        startPanCameraY = cameraY;
        canvas.classList.add('panning');
      }
    });

    window.addEventListener('mousemove', (evt) => {
      if (!isPanning) return;
      const dx = evt.clientX - startPanMouseX;
      const dy = evt.clientY - startPanMouseY;
      cameraX = startPanCameraX - dx;
      cameraY = startPanCameraY - dy;
      drawGrid();
    });

    window.addEventListener('mouseup', () => {
      if (!isPanning) return;
      isPanning = false;
      canvas.classList.remove('panning');
    });

    canvas.addEventListener('contextmenu', (evt) => {
      evt.preventDefault();
      if (!isPanning) {
        eraseAtMouse(evt);
      }
    });

    window.addEventListener('resize', resizeCanvas);
    loadPaintedCells();
    if (paintedCells.size === 0) {
      const initialHue = Math.floor(Math.random() * 360);
      lastPaintColor = `hsl(${initialHue}, 70%, 50%)`;
    }
    resizeCanvas();
  </script>
</body>
</html>
