<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>eightpaint</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background: #111;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #111;
      cursor: crosshair;
    }
    canvas.panning {
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <canvas id="hexCanvas"></canvas>

  <script>
    'use strict';

    // =====================================================
    // CONSTANTS & CONFIGURATION
    // =====================================================

    const canvas = document.getElementById('hexCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });

    // --- Grid geometry constants ---
    const hexSize = 16;
    const horiz = Math.sqrt(3) * hexSize;
    const vert = 1.5 * hexSize;

    // --- Persistence & sharing configuration ---
    const defaultColor = '#222';
    const storageKey = 'eightpaint-painted-cells-v1';
    const saveDelayMs = 1000;
    const stateQueryKey = 'state';

    // --- Color Schemes (9 palettes with smooth transitions) ---
    const colorSchemes = {
      swamp: ['#4f772d', '#31572c', '#90a955', '#7f4f24', '#a7c957', '#588157', '#3a5a40', '#606c38'],
      lava: ['#ffba08', '#faa307', '#f48c06', '#e85d04', '#dc2f02', '#d00000', '#9d0208', '#ff7b00'],
      ice: ['#caf0f8', '#ade8f4', '#90e0ef', '#48cae4', '#00b4d8', '#0096c7', '#0077b6', '#023e8a'],
      pastel: ['#ffd6e0', '#ffc6ff', '#caffbf', '#bde0fe', '#a0c4ff', '#ffadad', '#fdffb6', '#cdb4db'],
      mono: ['#000000', '#ffffff'],
      rainbow: ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#8b00ff', '#ff1493'],
      candy: ['#ff3c8e', '#ff8c42', '#ffd23f', '#2ec4b6', '#6a4c93', '#ff99c8', '#caffbf', '#9bf6ff'],
      forest: ['#1b4332', '#2d6a4f', '#40916c', '#52b788', '#74c69d', '#95d5b2', '#b7e4c7', '#081c15'],
      ocean: ['#03045e', '#023e8a', '#0077b6', '#0096c7', '#00b4d8', '#48cae4', '#90e0ef', '#caf0f8']
    };

    const schemeOrder = ['swamp', 'lava', 'ice', 'pastel', 'mono', 'rainbow', 'candy', 'forest', 'ocean'];

    // --- Hexagon neighbor offsets (for painting adjacent hexes) ---
    const evenRowNeighbors = [
      [+1,  0], [ 0, -1], [-1, -1],
      [-1,  0], [-1, +1], [ 0, +1],
    ];
    const oddRowNeighbors = [
      [+1,  0], [+1, -1], [ 0, -1],
      [-1,  0], [ 0, +1], [+1, +1],
    ];

    // =====================================================
    // STATE MANAGEMENT
    // =====================================================

    let activeSchemeIndex = 0;
    let paletteIndex = 0;

    // Camera/view state
    let cameraX = 0;
    let cameraY = 0;
    let currentZoom = 1;
    let targetZoom = 1;
    let zoomAnimationId = null;

    // Painted cells storage
    const paintedCells = new Map();

    // Interaction state
    let isMouseDown = false;
    let isPanning = false;
    let panBySpace = false;
    let isSpaceHeld = false;

    let startPanMouseX = 0;
    let startPanMouseY = 0;
    let startPanCameraX = 0;
    let startPanCameraY = 0;

    let saveTimerId = null;

    // =====================================================
    // UTILITY FUNCTIONS
    // =====================================================

    /**
     * Get the active color palette
     * @returns {Array<string>} Array of hex colors
     */
    function getActivePalette() {
      return colorSchemes[schemeOrder[activeSchemeIndex]];
    }

    /**
     * Create a unique key for a grid cell
     * @param {number} row - Row index
     * @param {number} col - Column index
     * @returns {string} Cell key
     */
    function cellKey(row, col) {
      return `${row},${col}`;
    }

    /**
     * Get the color of a cell, or default color if not painted
     * @param {number} row - Row index
     * @param {number} col - Column index
     * @returns {string} Hex color
     */
    function getCellColor(row, col) {
      return paintedCells.get(cellKey(row, col)) || defaultColor;
    }

    /**
     * Set the color of a cell
     * @param {number} row - Row index
     * @param {number} col - Column index
     * @param {string} color - Hex color
     */
    function setCellColor(row, col, color) {
      const key = cellKey(row, col);
      if (color === defaultColor) paintedCells.delete(key);
      else paintedCells.set(key, color);
    }

    /**
     * Check if space-based pan view is active
     * @returns {boolean} True if space key is held or panning by space
     */
    function isSpacePanViewActive() {
      return isSpaceHeld || panBySpace;
    }

    /**
     * Get the next color from the active palette
     * @returns {string} Hex color
     */
    function nextPaintColor() {
      const palette = getActivePalette();
      const color = palette[paletteIndex];
      paletteIndex = (paletteIndex + 1) % palette.length;
      return color;
    }

    /**
     * Cycle to the next or previous color scheme with smooth transition
     * @param {number} direction - 1 for next, -1 for previous
     */
    function cycleScheme(direction) {
      const total = schemeOrder.length;
      activeSchemeIndex = (activeSchemeIndex + direction + total) % total;
      paletteIndex = 0;
      updateShareUrl();
      drawGrid();
    }

    // =====================================================
    // ZOOM & ANIMATION
    // =====================================================

    /**
     * Set the target zoom level for space view
     * @param {boolean} shouldZoomOut - True to zoom out, false to zoom in
     */
    function setSpaceViewZoom(shouldZoomOut) {
      targetZoom = shouldZoomOut ? 0.9 : 1;
      if (!zoomAnimationId) zoomAnimationId = requestAnimationFrame(animateZoom);
    }

    /**
     * Animate smooth zoom transitions
     */
    function animateZoom() {
      const delta = targetZoom - currentZoom;
      if (Math.abs(delta) < 0.001) {
        currentZoom = targetZoom;
        zoomAnimationId = null;
        drawGrid();
        return;
      }
      currentZoom += delta * 0.18;
      drawGrid();
      zoomAnimationId = requestAnimationFrame(animateZoom);
    }

    // =====================================================
    // PERSISTENCE & SHARING
    // =====================================================

    /**
     * Encode state to base64 for URL sharing
     * @param {Object} state - State object with painting data
     * @returns {string} Base64 encoded state
     */
    function encodeStateToBase64(state) {
      const text = JSON.stringify(state);
      const bytes = new TextEncoder().encode(text);
      let binary = '';
      for (const b of bytes) binary += String.fromCharCode(b);
      return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
    }

    /**
     * Decode base64 state from URL
     * @param {string} encoded - Base64 encoded state
     * @returns {Object} Decoded state object
     */
    function decodeStateFromBase64(encoded) {
      const padded = encoded.replace(/-/g, '+').replace(/_/g, '/');
      const base = padded + '='.repeat((4 - (padded.length % 4)) % 4);
      const binary = atob(base);
      const bytes = Uint8Array.from(binary, (c) => c.charCodeAt(0));
      return JSON.parse(new TextDecoder().decode(bytes));
    }

    /**
     * Update the share URL with current state
     */
    function updateShareUrl() {
      try {
        const state = {
          s: schemeOrder[activeSchemeIndex],
          p: Object.fromEntries(paintedCells),
          c: [Math.round(cameraX), Math.round(cameraY)],
        };
        const encoded = encodeStateToBase64(state);
        const url = new URL(window.location.href);
        url.searchParams.set(stateQueryKey, encoded);
        window.history.replaceState(null, '', url.toString());
      } catch {
        // Silent fail - ignore encoding errors
      }
    }

    /**
     * Save painted cells to localStorage
     */
    function savePaintedCellsNow() {
      try {
        localStorage.setItem(storageKey, JSON.stringify(Object.fromEntries(paintedCells)));
      } catch {
        // Silent fail - localStorage might be unavailable
      }
      updateShareUrl();
    }

    /**
     * Queue a save operation (debounced)
     */
    function queueSavePaintedCells() {
      if (saveTimerId) return;
      saveTimerId = window.setTimeout(() => {
        saveTimerId = null;
        savePaintedCellsNow();
      }, saveDelayMs);
    }

    /**
     * Flush any pending save operation immediately
     */
    function flushQueuedSave() {
      if (saveTimerId) {
        clearTimeout(saveTimerId);
        saveTimerId = null;
      }
      savePaintedCellsNow();
    }

    /**
     * Load state from URL query parameter or localStorage
     */
    function loadStateFromQueryOrStorage() {
      // Try URL query parameter first
      try {
        const params = new URLSearchParams(window.location.search);
        const encodedState = params.get(stateQueryKey);
        if (encodedState) {
          const state = decodeStateFromBase64(encodedState);
          paintedCells.clear();

          if (state && typeof state.p === 'object' && state.p) {
            for (const [key, color] of Object.entries(state.p)) {
              if (typeof color === 'string' && color !== defaultColor) paintedCells.set(key, color);
            }
          }
          if (state && Array.isArray(state.c) && state.c.length === 2) {
            cameraX = Number(state.c[0]) || 0;
            cameraY = Number(state.c[1]) || 0;
          }
          if (state && typeof state.s === 'string') {
            const idx = schemeOrder.indexOf(state.s);
            if (idx >= 0) activeSchemeIndex = idx;
          }
          return;
        }
      } catch {
        // Fall through to localStorage
      }

      // Try localStorage as fallback
      try {
        const raw = localStorage.getItem(storageKey);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        for (const [key, color] of Object.entries(parsed)) {
          if (typeof color === 'string' && color !== defaultColor) paintedCells.set(key, color);
        }
      } catch {
        // Silent fail
      }
    }

    // =====================================================
    // GRID & RENDERING
    // =====================================================

    /**
     * Calculate the X center coordinate of a hexagon
     * @param {number} row - Row index
     * @param {number} col - Column index
     * @returns {number} World X coordinate
     */
    function hexCenterX(row, col) {
      return col * horiz + ((row & 1) ? horiz / 2 : 0);
    }

    /**
     * Draw a single hexagon on the canvas
     * @param {number} x - Screen X coordinate
     * @param {number} y - Screen Y coordinate
     * @param {string} color - Fill color
     * @param {string} strokeColor - Border color
     */
    function drawHex(x, y, color, strokeColor) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 180) * (60 * i + 30);
        const vx = x + hexSize * Math.cos(angle);
        const vy = y + hexSize * Math.sin(angle);
        if (i === 0) ctx.moveTo(vx, vy);
        else ctx.lineTo(vx, vy);
      }
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
      ctx.lineWidth = 1;
      ctx.strokeStyle = strokeColor;
      ctx.stroke();
    }

    /**
     * Render the entire hexagonal grid
     */
    function drawGrid() {
      const spaceMode = isSpacePanViewActive();
      const bgColor = spaceMode ? '#fff' : '#111';
      const strokeColor = spaceMode ? '#222' : '#444';

      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const worldWidth = canvas.width / currentZoom;
      const worldHeight = canvas.height / currentZoom;

      const worldMinX = cameraX - worldWidth / 2 - hexSize;
      const worldMaxX = cameraX + worldWidth / 2 + hexSize;
      const worldMinY = cameraY - worldHeight / 2 - hexSize;
      const worldMaxY = cameraY + worldHeight / 2 + hexSize;

      const minRow = Math.floor(worldMinY / vert) - 1;
      const maxRow = Math.ceil(worldMaxY / vert) + 1;

      for (let row = minRow; row <= maxRow; row++) {
        const shift = (row & 1) ? horiz / 2 : 0;
        const minCol = Math.floor((worldMinX - shift) / horiz) - 1;
        const maxCol = Math.ceil((worldMaxX - shift) / horiz) + 1;

        for (let col = minCol; col <= maxCol; col++) {
          const worldX = hexCenterX(row, col);
          const worldY = row * vert;

          const screenX = (worldX - cameraX) * currentZoom + canvas.width / 2;
          const screenY = (worldY - cameraY) * currentZoom + canvas.height / 2;

          const fillColor = spaceMode ? '#000' : getCellColor(row, col);
          drawHex(screenX, screenY, fillColor, strokeColor);
        }
      }

      canvas.style.background = bgColor;
      document.body.style.background = bgColor;
    }

    /**
     * Convert screen coordinates to grid cell
     * @param {number} mouseX - Screen X
     * @param {number} mouseY - Screen Y
     * @returns {Object} {row, col}
     */
    function screenToCell(mouseX, mouseY) {
      const worldX = ((mouseX - canvas.width / 2) / currentZoom) + cameraX;
      const worldY = ((mouseY - canvas.height / 2) / currentZoom) + cameraY;
      const row = Math.floor(worldY / vert);
      const shift = (row & 1) ? horiz / 2 : 0;
      const col = Math.floor((worldX - shift) / horiz);
      return { row, col };
    }

    // =====================================================
    // INTERACTION HANDLERS
    // =====================================================

    /**
     * Paint a hexagon and its neighbors at the given screen coordinates
     * @param {number} clientX - Client X
     * @param {number} clientY - Client Y
     */
    function paintAtPoint(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = clientX - rect.left;
      const mouseY = clientY - rect.top;
      const { row, col } = screenToCell(mouseX, mouseY);

      const color = nextPaintColor();
      setCellColor(row, col, color);

      const neighbors = (row & 1) ? oddRowNeighbors : evenRowNeighbors;
      for (const [dx, dy] of neighbors) {
        setCellColor(row + dy, col + dx, color);
      }

      queueSavePaintedCells();
      drawGrid();
    }

    /**
     * Erase a hexagon and its neighbors at the given screen coordinates
     * @param {number} clientX - Client X
     * @param {number} clientY - Client Y
     */
    function eraseAtPoint(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = clientX - rect.left;
      const mouseY = clientY - rect.top;
      const { row, col } = screenToCell(mouseX, mouseY);

      setCellColor(row, col, defaultColor);

      const neighbors = (row & 1) ? oddRowNeighbors : evenRowNeighbors;
      for (const [dx, dy] of neighbors) {
        setCellColor(row + dy, col + dx, defaultColor);
      }

      queueSavePaintedCells();
      drawGrid();
    }

    /**
     * Start panning the view
     * @param {number} clientX - Client X
     * @param {number} clientY - Client Y
     * @param {boolean} bySpace - Whether panning via space key
     */
    function startPan(clientX, clientY, bySpace = false) {
      isPanning = true;
      panBySpace = bySpace;
      startPanMouseX = clientX;
      startPanMouseY = clientY;
      startPanCameraX = cameraX;
      startPanCameraY = cameraY;
      canvas.classList.add('panning');
    }

    /**
     * Stop panning the view
     */
    function stopPan() {
      isPanning = false;
      panBySpace = false;
      canvas.classList.remove('panning');
      updateShareUrl();
    }

    // =====================================================
    // EVENT LISTENERS
    // =====================================================

    canvas.addEventListener('mousedown', (evt) => {
      isMouseDown = true;

      // Middle click OR Space-held OR Shift+Left => pan
      if (evt.button === 1 || isSpaceHeld || (evt.button === 0 && evt.shiftKey)) {
        startPan(evt.clientX, evt.clientY, isSpaceHeld);
        return;
      }

      if (evt.button === 0) paintAtPoint(evt.clientX, evt.clientY);
    });

    window.addEventListener('mousemove', (evt) => {
      if (isPanning) {
        const dx = evt.clientX - startPanMouseX;
        const dy = evt.clientY - startPanMouseY;
        cameraX = startPanCameraX - (dx / currentZoom);
        cameraY = startPanCameraY - (dy / currentZoom);
        drawGrid();
        return;
      }

      // Drag paint
      if (isMouseDown && (evt.buttons & 1) && !isSpaceHeld) {
        paintAtPoint(evt.clientX, evt.clientY);
      }
    });

    window.addEventListener('mouseup', (evt) => {
      isMouseDown = false;
      if (evt.button === 0 || evt.button === 1 || evt.button === 2) stopPan();
      flushQueuedSave();
    });

    window.addEventListener('keydown', (evt) => {
      if (evt.code === 'Space') {
        evt.preventDefault();
        if (!isSpaceHeld) {
          isSpaceHeld = true;
          setSpaceViewZoom(true);
        }
      }
    });

    window.addEventListener('keyup', (evt) => {
      if (evt.code === 'Space') {
        evt.preventDefault();
        isSpaceHeld = false;
        if (panBySpace) stopPan();
        setSpaceViewZoom(false);
      }
    });

    /**
     * Wheel event cycles through color schemes
     */
    canvas.addEventListener('wheel', (evt) => {
      evt.preventDefault();
      const direction = (evt.deltaY || evt.deltaX) >= 0 ? 1 : -1;
      cycleScheme(direction);
    }, { passive: false });

    canvas.addEventListener('contextmenu', (evt) => {
      evt.preventDefault();
      if (!isPanning) eraseAtPoint(evt.clientX, evt.clientY);
    });

    window.addEventListener('blur', () => {
      isMouseDown = false;
      isSpaceHeld = false;
      stopPan();
      setSpaceViewZoom(false);
      flushQueuedSave();
    });

    window.addEventListener('beforeunload', flushQueuedSave);

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      drawGrid();
    });

    // =====================================================
    // INITIALIZATION
    // =====================================================

    loadStateFromQueryOrStorage();
    updateShareUrl();

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    drawGrid();
  </script>
</body>
</html>
