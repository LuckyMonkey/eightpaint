<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>eightpaint</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background: #111;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #111;
      cursor: pointer;
    }
    canvas.space-mode {
      cursor: grab;
    }
    canvas.panning {
      cursor: grabbing;
    }
    #schemeIndicator {
      position: fixed;
      left: 0;
      top: 0;
      pointer-events: none;
      font-family: "Trebuchet MS", "Avenir Next", "Segoe UI", sans-serif;
      font-size: 15px;
      font-weight: 700;
      letter-spacing: 0.03em;
      text-transform: none;
      color: #fff;
      text-shadow: 0 0 12px rgba(0, 0, 0, 0.7);
      transform: translate(14px, -14px);
      opacity: 0;
      transition: opacity 320ms ease-out;
      mix-blend-mode: screen;
      white-space: nowrap;
      padding: 4px 8px;
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.22);
    }
  </style>
</head>
<body>
  <canvas id="hexCanvas"></canvas>
  <div id="schemeIndicator"></div>

  <script>
    'use strict';

    const canvas = document.getElementById('hexCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const schemeIndicator = document.getElementById('schemeIndicator');

    const hexSize = 16;
    const horiz = Math.sqrt(3) * hexSize;
    const vert = 1.5 * hexSize;

    const defaultColor = '#222';
    const storageKey = 'eightpaint-painted-cells-v1';
    const saveDelayMs = 1000;
    const stateQueryKey = 'state';

    const colorSchemes = {
      swamp: ['#4f772d', '#31572c', '#90a955', '#7f4f24', '#a7c957', '#588157', '#3a5a40', '#606c38'],
      lava: ['#ffba08', '#faa307', '#f48c06', '#e85d04', '#dc2f02', '#d00000', '#9d0208', '#ff7b00'],
      ice: ['#caf0f8', '#ade8f4', '#90e0ef', '#48cae4', '#00b4d8', '#0096c7', '#0077b6', '#023e8a'],
      pastel: ['#ffd6e0', '#ffc6ff', '#caffbf', '#bde0fe', '#a0c4ff', '#ffadad', '#fdffb6', '#cdb4db'],
      mono: ['#000000', '#ffffff'],
      rainbow: ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#8b00ff', '#ff1493'],
      candy: ['#ff3c8e', '#ff8c42', '#ffd23f', '#2ec4b6', '#6a4c93', '#ff99c8', '#caffbf', '#9bf6ff'],
      forest: ['#1b4332', '#2d6a4f', '#40916c', '#52b788', '#74c69d', '#95d5b2', '#b7e4c7', '#081c15'],
      ocean: ['#03045e', '#023e8a', '#0077b6', '#0096c7', '#00b4d8', '#48cae4', '#90e0ef', '#caf0f8']
    };

    const schemeOrder = ['swamp', 'lava', 'ice', 'pastel', 'mono', 'rainbow', 'candy', 'forest', 'ocean'];
    const schemeLabelColors = {
      mono: '#f3f3f3',
      ocean: '#8fe9ff',
    };

    const evenRowNeighbors = [
      [+1,  0], [ 0, -1], [-1, -1],
      [-1,  0], [-1, +1], [ 0, +1],
    ];
    const oddRowNeighbors = [
      [+1,  0], [+1, -1], [ 0, -1],
      [-1,  0], [ 0, +1], [+1, +1],
    ];

    let activeSchemeIndex = 0;
    let paletteIndex = 0;

    let cameraX = 0;
    let cameraY = 0;
    let currentZoom = 1;
    let targetZoom = 1;
    let zoomAnimationId = null;

    const paintedCells = new Map();

    let isMouseDown = false;
    let isPanning = false;
    let panBySpace = false;
    let isSpaceHeld = false;

    let startPanMouseX = 0;
    let startPanMouseY = 0;
    let panTargetCameraX = 0;
    let panTargetCameraY = 0;

    const panSpeedMultiplier = 1.5;
    const panSmoothing = 0.26;

    let pointerX = 0;
    let pointerY = 0;
    let indicatorFadeTimerId = null;

    let saveTimerId = null;

    function getActivePalette() {
      return colorSchemes[schemeOrder[activeSchemeIndex]];
    }

    function cellKey(row, col) {
      return `${row},${col}`;
    }

    function getCellColor(row, col) {
      return paintedCells.get(cellKey(row, col)) || defaultColor;
    }

    function setCellColor(row, col, color) {
      const key = cellKey(row, col);
      if (color === defaultColor) paintedCells.delete(key);
      else paintedCells.set(key, color);
    }

    function isSpacePanViewActive() {
      return isSpaceHeld || panBySpace;
    }

    function nextPaintColor() {
      const palette = getActivePalette();
      const color = palette[paletteIndex];
      paletteIndex = (paletteIndex + 1) % palette.length;
      return color;
    }

    function luminance(hexColor) {
      const c = hexColor.replace('#', '');
      if (c.length !== 6) return 0;
      const r = parseInt(c.slice(0, 2), 16);
      const g = parseInt(c.slice(2, 4), 16);
      const b = parseInt(c.slice(4, 6), 16);
      return (0.2126 * r) + (0.7152 * g) + (0.0722 * b);
    }

    function toMonochrome(hexColor) {
      return luminance(hexColor) >= 128 ? '#fff' : '#000';
    }

    function updateSchemeIndicatorPosition(clientX, clientY) {
      schemeIndicator.style.left = `${clientX}px`;
      schemeIndicator.style.top = `${clientY}px`;
    }

    function showSchemeIndicator() {
      const schemeName = schemeOrder[activeSchemeIndex];
      const swatch = getActivePalette()[0];
      const labelColor = schemeLabelColors[schemeName] || swatch;
      schemeIndicator.textContent = schemeName.toLowerCase();
      schemeIndicator.style.color = labelColor;
      schemeIndicator.style.opacity = '1';

      if (indicatorFadeTimerId) {
        clearTimeout(indicatorFadeTimerId);
      }

      indicatorFadeTimerId = window.setTimeout(() => {
        schemeIndicator.style.opacity = '0';
      }, 1000);
    }

    function cycleScheme(direction) {
      const total = schemeOrder.length;
      activeSchemeIndex = (activeSchemeIndex + direction + total) % total;
      paletteIndex = 0;
      showSchemeIndicator();
      updateShareUrl();
      drawGrid();
    }

    function setSpaceViewZoom(shouldZoomOut) {
      targetZoom = shouldZoomOut ? 0.42 : 1;
      if (!zoomAnimationId) zoomAnimationId = requestAnimationFrame(animateZoom);
    }

    function animateZoom() {
      const zoomDelta = targetZoom - currentZoom;
      const panDeltaX = panTargetCameraX - cameraX;
      const panDeltaY = panTargetCameraY - cameraY;

      if (Math.abs(zoomDelta) < 0.001 && Math.abs(panDeltaX) < 0.3 && Math.abs(panDeltaY) < 0.3) {
        currentZoom = targetZoom;
        cameraX = panTargetCameraX;
        cameraY = panTargetCameraY;
        zoomAnimationId = null;
        drawGrid();
        return;
      }

      currentZoom += zoomDelta * 0.2;
      cameraX += panDeltaX * panSmoothing;
      cameraY += panDeltaY * panSmoothing;
      drawGrid();
      zoomAnimationId = requestAnimationFrame(animateZoom);
    }

    function encodeStateToBase64(state) {
      const text = JSON.stringify(state);
      const bytes = new TextEncoder().encode(text);
      let binary = '';
      for (const b of bytes) binary += String.fromCharCode(b);
      return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
    }

    function decodeStateFromBase64(encoded) {
      const padded = encoded.replace(/-/g, '+').replace(/_/g, '/');
      const base = padded + '='.repeat((4 - (padded.length % 4)) % 4);
      const binary = atob(base);
      const bytes = Uint8Array.from(binary, (c) => c.charCodeAt(0));
      return JSON.parse(new TextDecoder().decode(bytes));
    }

    function updateShareUrl() {
      try {
        const state = {
          s: schemeOrder[activeSchemeIndex],
          p: Object.fromEntries(paintedCells),
          c: [Math.round(cameraX), Math.round(cameraY)],
        };
        const encoded = encodeStateToBase64(state);
        const url = new URL(window.location.href);
        url.searchParams.set(stateQueryKey, encoded);
        window.history.replaceState(null, '', url.toString());
      } catch {
      }
    }

    function savePaintedCellsNow() {
      try {
        localStorage.setItem(storageKey, JSON.stringify(Object.fromEntries(paintedCells)));
      } catch {
      }
      updateShareUrl();
    }

    function queueSavePaintedCells() {
      if (saveTimerId) return;
      saveTimerId = window.setTimeout(() => {
        saveTimerId = null;
        savePaintedCellsNow();
      }, saveDelayMs);
    }

    function flushQueuedSave() {
      if (saveTimerId) {
        clearTimeout(saveTimerId);
        saveTimerId = null;
      }
      savePaintedCellsNow();
    }

    function loadStateFromQueryOrStorage() {
      try {
        const params = new URLSearchParams(window.location.search);
        const encodedState = params.get(stateQueryKey);
        if (encodedState) {
          const state = decodeStateFromBase64(encodedState);
          paintedCells.clear();

          if (state && typeof state.p === 'object' && state.p) {
            for (const [key, color] of Object.entries(state.p)) {
              if (typeof color === 'string' && color !== defaultColor) paintedCells.set(key, color);
            }
          }
          if (state && Array.isArray(state.c) && state.c.length === 2) {
            cameraX = Number(state.c[0]) || 0;
            cameraY = Number(state.c[1]) || 0;
            panTargetCameraX = cameraX;
            panTargetCameraY = cameraY;
          }
          if (state && typeof state.s === 'string') {
            const idx = schemeOrder.indexOf(state.s);
            if (idx >= 0) activeSchemeIndex = idx;
          }
          return;
        }
      } catch {
      }

      try {
        const raw = localStorage.getItem(storageKey);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        for (const [key, color] of Object.entries(parsed)) {
          if (typeof color === 'string' && color !== defaultColor) paintedCells.set(key, color);
        }
      } catch {
      }
    }

    function hexCenterX(row, col) {
      return col * horiz + ((row & 1) ? horiz / 2 : 0);
    }

    function drawHex(x, y, color, strokeColor) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 180) * (60 * i + 30);
        const vx = x + hexSize * Math.cos(angle) * currentZoom;
        const vy = y + hexSize * Math.sin(angle) * currentZoom;
        if (i === 0) ctx.moveTo(vx, vy);
        else ctx.lineTo(vx, vy);
      }
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
      ctx.lineWidth = Math.max(0.6, currentZoom);
      ctx.strokeStyle = strokeColor;
      ctx.stroke();
    }

    function drawGrid() {
      const spaceMode = isSpacePanViewActive();
      const bgColor = spaceMode ? '#fff' : '#111';
      const strokeColor = spaceMode ? '#111' : '#444';

      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const worldWidth = canvas.width / currentZoom;
      const worldHeight = canvas.height / currentZoom;

      const worldMinX = cameraX - worldWidth / 2 - hexSize;
      const worldMaxX = cameraX + worldWidth / 2 + hexSize;
      const worldMinY = cameraY - worldHeight / 2 - hexSize;
      const worldMaxY = cameraY + worldHeight / 2 + hexSize;

      const minRow = Math.floor(worldMinY / vert) - 1;
      const maxRow = Math.ceil(worldMaxY / vert) + 1;

      for (let row = minRow; row <= maxRow; row++) {
        const shift = (row & 1) ? horiz / 2 : 0;
        const minCol = Math.floor((worldMinX - shift) / horiz) - 1;
        const maxCol = Math.ceil((worldMaxX - shift) / horiz) + 1;

        for (let col = minCol; col <= maxCol; col++) {
          const worldX = hexCenterX(row, col);
          const worldY = row * vert;

          const screenX = (worldX - cameraX) * currentZoom + canvas.width / 2;
          const screenY = (worldY - cameraY) * currentZoom + canvas.height / 2;

          const baseColor = getCellColor(row, col);
          const fillColor = spaceMode ? toMonochrome(baseColor) : baseColor;
          drawHex(screenX, screenY, fillColor, strokeColor);
        }
      }

      canvas.classList.toggle('space-mode', spaceMode);
      canvas.style.background = bgColor;
      document.body.style.background = bgColor;
    }

    function screenToCell(mouseX, mouseY) {
      const worldX = ((mouseX - canvas.width / 2) / currentZoom) + cameraX;
      const worldY = ((mouseY - canvas.height / 2) / currentZoom) + cameraY;
      const row = Math.floor(worldY / vert);
      const shift = (row & 1) ? horiz / 2 : 0;
      const col = Math.floor((worldX - shift) / horiz);
      return { row, col };
    }

    function paintAtPoint(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = clientX - rect.left;
      const mouseY = clientY - rect.top;
      const { row, col } = screenToCell(mouseX, mouseY);

      const color = nextPaintColor();
      setCellColor(row, col, color);

      const neighbors = (row & 1) ? oddRowNeighbors : evenRowNeighbors;
      for (const [dx, dy] of neighbors) {
        setCellColor(row + dy, col + dx, color);
      }

      queueSavePaintedCells();
      drawGrid();
    }

    function eraseAtPoint(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = clientX - rect.left;
      const mouseY = clientY - rect.top;
      const { row, col } = screenToCell(mouseX, mouseY);

      setCellColor(row, col, defaultColor);

      const neighbors = (row & 1) ? oddRowNeighbors : evenRowNeighbors;
      for (const [dx, dy] of neighbors) {
        setCellColor(row + dy, col + dx, defaultColor);
      }

      queueSavePaintedCells();
      drawGrid();
    }

    function startPan(clientX, clientY, bySpace = false) {
      isPanning = true;
      panBySpace = bySpace;
      startPanMouseX = clientX;
      startPanMouseY = clientY;
      panTargetCameraX = cameraX;
      panTargetCameraY = cameraY;
      canvas.classList.add('panning');
    }

    function stopPan() {
      isPanning = false;
      panBySpace = false;
      canvas.classList.remove('panning');
      updateShareUrl();
    }

    canvas.addEventListener('mousedown', (evt) => {
      isMouseDown = true;
      pointerX = evt.clientX;
      pointerY = evt.clientY;

      if (evt.button === 1 || isSpaceHeld || (evt.button === 0 && evt.shiftKey)) {
        startPan(evt.clientX, evt.clientY, isSpaceHeld);
        return;
      }

      if (evt.button === 0) paintAtPoint(evt.clientX, evt.clientY);
    });

    window.addEventListener('mousemove', (evt) => {
      pointerX = evt.clientX;
      pointerY = evt.clientY;
      updateSchemeIndicatorPosition(pointerX, pointerY);

      if (isPanning) {
        const dx = evt.clientX - startPanMouseX;
        const dy = evt.clientY - startPanMouseY;
        panTargetCameraX = cameraX - ((dx / currentZoom) * panSpeedMultiplier);
        panTargetCameraY = cameraY - ((dy / currentZoom) * panSpeedMultiplier);
        startPanMouseX = evt.clientX;
        startPanMouseY = evt.clientY;
        if (!zoomAnimationId) zoomAnimationId = requestAnimationFrame(animateZoom);
        return;
      }

      if (isMouseDown && (evt.buttons & 1) && !isSpaceHeld) {
        paintAtPoint(evt.clientX, evt.clientY);
      }
    });

    window.addEventListener('mouseup', (evt) => {
      isMouseDown = false;
      if (evt.button === 0 || evt.button === 1 || evt.button === 2) stopPan();
      flushQueuedSave();
    });

    window.addEventListener('keydown', (evt) => {
      if (evt.code === 'Space') {
        evt.preventDefault();
        if (!isSpaceHeld) {
          isSpaceHeld = true;
          setSpaceViewZoom(true);
          drawGrid();
        }
      }
    });

    window.addEventListener('keyup', (evt) => {
      if (evt.code === 'Space') {
        evt.preventDefault();
        isSpaceHeld = false;
        if (panBySpace) stopPan();
        setSpaceViewZoom(false);
      }
    });

    canvas.addEventListener('wheel', (evt) => {
      evt.preventDefault();
      pointerX = evt.clientX;
      pointerY = evt.clientY;
      updateSchemeIndicatorPosition(pointerX, pointerY);
      const direction = (evt.deltaY || evt.deltaX) >= 0 ? 1 : -1;
      cycleScheme(direction);
    }, { passive: false });

    canvas.addEventListener('contextmenu', (evt) => {
      evt.preventDefault();
      if (!isPanning) eraseAtPoint(evt.clientX, evt.clientY);
    });

    window.addEventListener('blur', () => {
      isMouseDown = false;
      isSpaceHeld = false;
      stopPan();
      setSpaceViewZoom(false);
      flushQueuedSave();
    });

    window.addEventListener('beforeunload', flushQueuedSave);

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      drawGrid();
    });

    loadStateFromQueryOrStorage();
    updateShareUrl();

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    updateSchemeIndicatorPosition(window.innerWidth / 2, window.innerHeight / 2);
    drawGrid();
  </script>
</body>
</html>
